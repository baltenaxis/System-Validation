map
  NUM_WAFERS  : Nat;  NUM_ROBOTS  : Nat;  NUM_SLUICES : Nat;
  NUM_FOUP_IN : Nat;  NUM_FOUP_OUT: Nat;
eqn
  NUM_WAFERS   = 1;  NUM_ROBOTS   = 1;  NUM_SLUICES  = 1;
  NUM_FOUP_IN  = 1;  NUM_FOUP_OUT = 1;

sort
  Robot    = struct r(n:Nat);
  SluiceId = struct s(n:Nat);
  Door     = struct inner | outer;
  Wafer    = struct w(n:Nat);
  Loc      =
      struct in_cell(n:Nat)
           | sl_out(SluiceId)   % exterior side (robot side)
           | sl_in(SluiceId)    % interior buffer
           | waiting
           | stage
           | out_cell(n:Nat);

map validRobot   : Robot    -> Bool;  validSluice  : SluiceId -> Bool;
    validWafer   : Wafer    -> Bool;  validInCell  : Nat      -> Bool;
    validOutCell : Nat      -> Bool;
var k:Nat;
eqn
  validRobot(r(k))  = k < NUM_ROBOTS;
  validSluice(s(k)) = k < NUM_SLUICES;
  validWafer(w(k))  = k < NUM_WAFERS;
  validInCell(k)    = k < NUM_FOUP_IN;
  validOutCell(k)   = k < NUM_FOUP_OUT;

act
  % Sluice door/pump
  open, close : Door # SluiceId;
  pump_cycle_start, vacuum_ready, vacuum_fault : SluiceId;

  % Wafer handling
  pick, place : Robot # Wafer # Loc;
  transfer_in, transfer_out : Wafer # SluiceId;   % put/take through sluice

  % Stage
  stage_load, proj_start, proj_end, stage_unload : Wafer;
  clamp, unclamp;

  % I/O + alarm
  entered_system, output : Wafer;
  alarm_on : SluiceId;  alarm_off;

% ---------- Static defaults (cheap, just to give initial readings)
map inner_open, outer_open, eq_pressure, pumping_m : SluiceId -> Bool;
    occ_sl_buf : SluiceId -> Bool;
    where      : Wafer -> Loc;
var sid:SluiceId; kw:Nat;
eqn inner_open(sid)=false; outer_open(sid)=false; eq_pressure(sid)=true; pumping_m(sid)=false;
    occ_sl_buf(sid)=false; where(w(kw)) = in_cell(kw);

% ---------- SLUICE: doors + pump + 1-slot buffer with guards that create petals
proc Sluice(sid:SluiceId, in_open:Bool, out_open:Bool, equalised:Bool,
            pumping:Bool, buf_occ:Bool) =

  % Door toggles (each creates a “petal” self-loop possibility)
  ( !in_open && equalised && !pumping ) ->
    ( open(inner,sid) . Sluice(sid,true ,out_open,equalised,pumping,buf_occ) ) <> delta
+
  (  in_open                             ) ->
    ( close(inner,sid). Sluice(sid,false,out_open,equalised,pumping,buf_occ) ) <> delta
+
  ( !out_open && equalised && !pumping ) ->
    ( open(outer,sid) . Sluice(sid,in_open,true ,equalised,pumping,buf_occ) ) <> delta
+
  (  out_open                           ) ->
    ( close(outer,sid). Sluice(sid,in_open,false,equalised,pumping,buf_occ) ) <> delta
+
  % Pump cycle (both doors closed)
  ( !in_open && !out_open && !pumping ) ->
    ( pump_cycle_start(sid) . Sluice(sid,in_open,out_open,false,true,buf_occ) ) <> delta
+
  ( pumping ) ->
    ( vacuum_ready(sid) . Sluice(sid,in_open,out_open,true,false,buf_occ) ) <> delta
+
  % “Put into sluice” (outer door open, inner closed)
  ( out_open && !in_open && !pumping && !buf_occ ) ->
    ( transfer_in(w(0),sid) . Sluice(sid,in_open,out_open,equalised,pumping,true) ) <> delta
+
  % “Take from sluice” (inner door open, outer closed)
  ( in_open && !out_open && !pumping &&  buf_occ ) ->
    ( transfer_out(w(0),sid) . Sluice(sid,in_open,out_open,equalised,pumping,false) ) <> delta
+
  % Optional fault -> alarm (kept simple)
  vacuum_fault(sid) . alarm_on(sid) . Sluice(sid,in_open,out_open,equalised,pumping,buf_occ)
;

% ---------- STAGE: one-slot process with its own petals
proc Stage(occ:Bool, clamped:Bool, done:Bool) =
  ( !occ )                  -> ( stage_load(w(0)) . Stage(true,false,false) ) <> delta
+
  ( occ && !clamped )       -> ( clamp . Stage(true,true,done) ) <> delta
+
  ( occ && clamped && !done )->( proj_start(w(0)) . proj_end(w(0)) . Stage(true,true,true) ) <> delta
+
  ( occ && clamped && done )-> ( unclamp . Stage(true,false,done) ) <> delta
+
  ( occ && !clamped && done )->( stage_unload(w(0)) . Stage(false,false,false) ) <> delta
;

% ---------- ROBOT: now concurrent, interacts with sluice & stage
% phases:
% 0 pick in_cell(0)  -> sl_out
% 1 transfer_in via sluice (Sluice must allow it) [Robot waits by placing at sl_out]
% 2 after transfer_out, place to stage
% 3 after stage cycle, place to out_cell(0) -> output
proc Robot(rb:Robot, phase:Nat) =
  ( phase == 0 ) ->
    ( pick(rb,w(0),in_cell(0)) . entered_system(w(0)) .
      place(rb,w(0),sl_out(s(0))) .
      Robot(rb,1) ) <> delta
+
  % Robot asks the sluice to accept wafer (will only succeed when outer door open etc.)
  ( phase == 1 ) ->
    ( transfer_in(w(0),s(0)) .
      Robot(rb,2) ) <> delta
+
  % Robot retrieves wafer from inside (requires inner door open etc.)
  ( phase == 2 ) ->
    ( transfer_out(w(0),s(0)) .
      place(rb,w(0),stage) .
      Robot(rb,3) ) <> delta
+
  ( phase == 3 ) ->
    ( place(rb,w(0),out_cell(0)) . output(w(0)) .
      Robot(rb,3) ) <> delta
;

% ---------- ALARM (passive unless a fault occurs)
proc Alarm = alarm_off . Alarm + delta;


% ---------- SYSTEM: three components in parallel (causes the interleavings)
proc System =
  Sluice(s(0), false,false, true,false, false)
  || Stage(false,false,false)
  || Robot(r(0),0)
  || Alarm;

init allow(
  { open,close,pump_cycle_start,vacuum_ready,vacuum_fault,
    pick,place,transfer_in,transfer_out,
    stage_load,clamp,proj_start,proj_end,stage_unload,
    entered_system,output,alarm_on,alarm_off }, System);
