% ==============================================================
% ASML_3component_parallel_FIXED_v2.mcrl2
% Fixes: 
%   1. Action naming conflict (transfer_in/out used for two purposes)
%   2. Door safety properties S4a, S4b
%   3. Processing requirement before output
% ==============================================================

map
  NUM_WAFERS  : Nat;  NUM_SLUICES : Nat;
  NUM_FOUP_IN : Nat;  NUM_FOUP_OUT: Nat;
eqn
  NUM_WAFERS   = 2;
  NUM_SLUICES  = 2;
  NUM_FOUP_IN  = 2;
  NUM_FOUP_OUT = 2;

sort
  SluiceId = struct s(n:Nat);
  Wafer    = struct w(n:Nat);

  Loc =
      struct in_cell(n:Nat)
           | sl_out(SluiceId)
           | sl_in(SluiceId)
           | waiting
           | stage
           | out_cell(n:Nat);

  PMode = struct Atm | Pumping | Vac | Venting;

  MOptWafer = struct none | some(Wafer);

act
  % Observable actions
  open_inner, close_inner : SluiceId;
  open_outer, close_outer : SluiceId;
  start_pump_down, vacuum_achieved : SluiceId;
  start_vent, atmosphere_achieved  : SluiceId;
  vacuum_fault : SluiceId;

  % Sluice-Outside interface (use outer door)
  transfer_in, transfer_out : Wafer # SluiceId;
  
  % Sluice-Inside interface (use inner door) - RENAMED to avoid conflict
  sluice_to_chamber, chamber_to_sluice : Wafer # SluiceId;
  
  pick, place : Wafer # Loc;

  load_stage, start_projection, end_projection, unload_stage : Wafer;

  wafer_entered_system, wafer_output : Wafer;

  trigger_alarm, restart_system;

  % Communication actions (internal)
  or_place_ext, sl_accept_ext : Wafer # SluiceId;
  or_pick_ext, sl_release_ext : Wafer # SluiceId;
  
  % Renamed: sluice->inside communication
  sl_transfer_to_inside, inside_accept_from_sluice : Wafer # SluiceId;
  % Renamed: inside->sluice communication
  inside_transfer_to_sluice, sluice_accept_from_inside : Wafer # SluiceId;

  alarm_trigger_internal, alarm_receive_trigger;
  alarm_restart_internal, alarm_receive_restart;

  c_place_ext, c_pick_ext : Wafer # SluiceId;

% ----------------------------------------------
% Helpers
% ----------------------------------------------
map
  validSluice  : SluiceId -> Bool;
  validWafer   : Wafer    -> Bool;
  validInCell  : Nat      -> Bool;
  validOutCell : Nat      -> Bool;
  sid2n        : SluiceId -> Nat;
  w2n          : Wafer    -> Nat;

var k:Nat; sid:SluiceId; wf:Wafer;

eqn
  sid2n(s(k)) = k;
  w2n(w(k))   = k;

  validSluice(sid) = sid2n(sid) < NUM_SLUICES;
  validWafer(wf)   = w2n(wf)    < NUM_WAFERS;
  validInCell(k)   = k < NUM_FOUP_IN;
  validOutCell(k)  = k < NUM_FOUP_OUT;

% ==============================================================
% COMPONENT 1: Outside Robot Controller (Region 1)
% ==============================================================
proc OutsideRobotController(
  phase    : Wafer -> Nat,
  out_occ  : Nat   -> Bool,
  alarm    : Bool
) =
  sum i:Nat, sid:SluiceId . (
      i < NUM_WAFERS && validInCell(i) && validSluice(sid) && 
      !alarm && phase(w(i)) == 0
    ) -> pick(w(i), in_cell(i)) . wafer_entered_system(w(i)) . 
         or_place_ext(w(i), sid) .
         OutsideRobotController(phase[w(i)->1], out_occ, alarm)
+
  sum sid:SluiceId, i:Nat, oc:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      validOutCell(oc) && !out_occ(oc) && !alarm &&
      phase(w(i)) >= 1  % Wafer must have entered system
    ) -> or_pick_ext(w(i), sid) . 
         place(w(i), out_cell(oc)) . wafer_output(w(i)) .
         OutsideRobotController(phase[w(i)->2], out_occ[oc->true], alarm)
+
  alarm_receive_trigger . 
    OutsideRobotController(phase, out_occ, true)
+
  alarm_receive_restart .
    OutsideRobotController(phase, out_occ, false)
;

% ==============================================================
% COMPONENT 2: Sluice Controller (Region 2)
% ==============================================================
proc SluiceController(
  sid       : SluiceId,
  in_open   : Bool,
  out_open  : Bool,
  mode      : PMode,
  buf_occ   : Bool,
  buf_w     : MOptWafer,
  ext_port_w: MOptWafer,
  ext_is_output: Bool,
  from_inside: Bool,  % NEW: tracks if wafer came from inside chamber
  alarm     : Bool
) =
  % Open outer door (only when in atmosphere and doors closed)
  (mode == Atm && !out_open && !in_open && !alarm) 
    -> open_outer(sid) .
       SluiceController(sid, in_open, true, mode, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Close outer door
  (out_open) 
    -> close_outer(sid) .
       SluiceController(sid, in_open, false, mode, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Open inner door (only when in vacuum and doors closed)
  (mode == Vac && !in_open && !out_open && !alarm) 
    -> open_inner(sid) .
       SluiceController(sid, true, out_open, mode, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Close inner door
  (in_open) 
    -> close_inner(sid) .
       SluiceController(sid, false, out_open, mode, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Start pump down
  (!in_open && !out_open && mode == Atm && buf_occ && !alarm) 
    -> start_pump_down(sid) .
       SluiceController(sid, in_open, out_open, Pumping, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Achieve vacuum
  (mode == Pumping) 
    -> vacuum_achieved(sid) .
       SluiceController(sid, in_open, out_open, Vac, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Start venting
  (!in_open && !out_open && mode == Vac) 
    -> start_vent(sid) .
       SluiceController(sid, in_open, out_open, Venting, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Achieve atmosphere
  (mode == Venting) 
    -> atmosphere_achieved(sid) .
       SluiceController(sid, in_open, out_open, Atm, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % Vacuum fault during pumping
  (mode == Pumping && !alarm)
    -> vacuum_fault(sid) . 
       SluiceController(sid, in_open, out_open, Atm, buf_occ, buf_w, ext_port_w, ext_is_output, from_inside, alarm)
+
  % ============ SLUICE-OUTSIDE INTERFACE (outer door) ============
  
  % Accept wafer from outside robot to external port
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && ext_port_w == none
    ) -> sl_accept_ext(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, 
                         some(w(i)), false, from_inside, alarm)
+
  % Transfer from external port INTO sluice buffer (transfer_in)
  % This is the observable transfer_in that requires outer door open
  % Mark from_inside=false since wafer came from outside
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && !buf_occ &&
      ext_port_w == some(w(i))
    ) -> transfer_in(w(i), sid) . place(w(i), sl_in(sid)) .
         SluiceController(sid, in_open, out_open, mode, true, some(w(i)), 
                         none, false, false, alarm)
+
  % Transfer from sluice buffer OUT to external port (transfer_out)
  % This is the observable transfer_out that requires outer door open
  % ONLY ALLOW if from_inside=true (wafer must have been processed)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && buf_occ &&
      buf_w == some(w(i)) && ext_port_w == none && from_inside
    ) -> transfer_out(w(i), sid) . place(w(i), sl_out(sid)) .
         SluiceController(sid, in_open, out_open, mode, false, none, 
                         some(w(i)), true, false, alarm)
+
  % Release wafer to outside robot from external port
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm &&
      ext_port_w == some(w(i)) && ext_is_output
    ) -> sl_release_ext(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, 
                         none, false, from_inside, alarm)
+
  % ============ SLUICE-INSIDE INTERFACE (inner door) ============
  
  % Transfer from sluice buffer to inside chamber (sluice_to_chamber)
  % Requires inner door open - this will become observable sluice_to_chamber
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      in_open && !out_open && mode == Vac && buf_occ && !alarm &&
      buf_w == some(w(i))
    ) -> sl_transfer_to_inside(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, false, none, 
                         ext_port_w, ext_is_output, false, alarm)
+
  % Accept wafer from inside chamber to sluice buffer (chamber_to_sluice)
  % Requires inner door open - this will become observable chamber_to_sluice
  % Mark from_inside=true since wafer came from inside (processed)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      in_open && !out_open && mode == Vac && !buf_occ && !alarm
    ) -> sluice_accept_from_inside(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, true, some(w(i)), 
                         ext_port_w, ext_is_output, true, alarm)
+
  % Alarm handling
  alarm_receive_trigger . 
    SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, 
                    ext_port_w, ext_is_output, from_inside, true)
+
  alarm_receive_restart .
    SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, 
                    ext_port_w, ext_is_output, from_inside, false)
;

% ==============================================================
% COMPONENT 3: Inside Controller (Region 3 + Alarm)
% ==============================================================
proc InsideController(
  is_waiting: Wafer -> Bool,
  stage_busy: Bool,
  on_stage  : MOptWafer,
  processed : Wafer -> Bool,
  alarm     : Bool
) =
  % Trigger alarm
  (!alarm) 
    -> alarm_trigger_internal .
       InsideController(is_waiting, stage_busy, on_stage, processed, true)
+
  % Restart from alarm
  (alarm) 
    -> alarm_restart_internal .
       InsideController(is_waiting, stage_busy, on_stage, processed, false)
+
  % Accept wafer from sluice into waiting area
  sum sid:SluiceId, i:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      !alarm && !is_waiting(w(i))
    ) -> inside_accept_from_sluice(w(i), sid) . place(w(i), waiting) .
         InsideController(is_waiting[w(i)->true], stage_busy, on_stage, processed, alarm)
+
  % Transfer processed wafer back to sluice
  % ONLY AFTER PROCESSING - this enforces the projection requirement
  sum sid:SluiceId, i:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      !alarm && is_waiting(w(i)) && processed(w(i))
    ) -> inside_transfer_to_sluice(w(i), sid) . place(w(i), sl_in(sid)) .
         InsideController(is_waiting[w(i)->false], stage_busy, on_stage, processed, alarm)
+
  % Load, process, and mark as processed - all in one atomic sequence
  sum i:Nat . (
      i < NUM_WAFERS && is_waiting(w(i)) && !stage_busy && !alarm && !processed(w(i))
    ) -> load_stage(w(i)) . start_projection(w(i)) . end_projection(w(i)) .
         InsideController(is_waiting[w(i)->false], true, some(w(i)), 
                         processed[w(i)->true], alarm)
+
  % Unload from stage back to waiting
  sum i:Nat . (
      i < NUM_WAFERS && on_stage == some(w(i)) && !alarm
    ) -> unload_stage(w(i)) . place(w(i), waiting) .
         InsideController(is_waiting[w(i)->true], false, none, processed, alarm)
;

% ==============================================================
% INITIALIZATION
% ==============================================================
init
  allow({
    open_inner, close_inner, open_outer, close_outer,
    start_pump_down, vacuum_achieved, start_vent, atmosphere_achieved,
    vacuum_fault,
    transfer_in, transfer_out,           % Sluice-Outside (outer door)
    sluice_to_chamber, chamber_to_sluice, % Sluice-Inside (inner door)
    pick, place,
    load_stage, start_projection, end_projection, unload_stage,
    wafer_entered_system, wafer_output,
    trigger_alarm, restart_system,
    c_place_ext, c_pick_ext
  },
  comm({
    % Outside robot <-> Sluice external port
    or_place_ext | sl_accept_ext -> c_place_ext,
    or_pick_ext | sl_release_ext -> c_pick_ext,
    
    % Sluice buffer <-> Inside chamber (RENAMED to avoid conflict)
    sl_transfer_to_inside | inside_accept_from_sluice -> sluice_to_chamber,
    inside_transfer_to_sluice | sluice_accept_from_inside -> chamber_to_sluice,
    
    % Alarm coordination
    alarm_trigger_internal | alarm_receive_trigger -> trigger_alarm,
    alarm_restart_internal | alarm_receive_restart -> restart_system
  },
    OutsideRobotController(
      lambda wf:Wafer . 0,
      lambda k:Nat    . false,
      false
    )
    ||
    SluiceController(
      s(0), false, false, Vac, false, none, none, false, false, false
    )
    ||
    SluiceController(
      s(1), false, false, Vac, false, none, none, false, false, false
    )
    ||
    InsideController(
      lambda wf:Wafer . false,
      false,
      none,
      lambda wf:Wafer . false,
      false
    )
  ));