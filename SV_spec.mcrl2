% ==============================================================
% ASML_3component_parallel.mcrl2 â€” Refactored into 3 Parallel Components
% Component 1: OutsideRobotController (Region 1)
% Component 2: SluiceController (Region 2, one per sluice)
% Component 3: InsideController (Region 3 + Alarm)
% ==============================================================

map
  NUM_WAFERS  : Nat;  NUM_SLUICES : Nat;
  NUM_FOUP_IN : Nat;  NUM_FOUP_OUT: Nat;
eqn
  NUM_WAFERS   = 2;
  NUM_SLUICES  = 2;
  NUM_FOUP_IN  = 2;
  NUM_FOUP_OUT = 2;

sort
  SluiceId = struct s(n:Nat);
  Wafer    = struct w(n:Nat);

  Loc =
      struct in_cell(n:Nat)
           | sl_out(SluiceId)
           | sl_in(SluiceId)
           | waiting
           | stage
           | out_cell(n:Nat);

  PMode = struct Atm | Pumping | Vac | Venting;

  MOptWafer = struct none | some(Wafer);

act
  % Observable actions - same as before
  open_inner, close_inner : SluiceId;
  open_outer, close_outer : SluiceId;
  start_pump_down, vacuum_achieved : SluiceId;
  start_vent, atmosphere_achieved  : SluiceId;
  vacuum_fault : SluiceId;

  transfer_in, transfer_out : Wafer # SluiceId;
  pick, place : Wafer # Loc;

  load_stage, start_projection, end_projection, unload_stage : Wafer;

  wafer_entered_system, wafer_output : Wafer;

  trigger_alarm, restart_system;

  % Communication actions (internal, will be hidden)
  % For Outside Robot <-> Sluice communication
  or_place_ext, sl_accept_ext : Wafer # SluiceId;  % Outside places at sl_out
  or_pick_ext, sl_release_ext : Wafer # SluiceId;  % Outside picks from sl_out
  
  % For Sluice <-> Inside communication  
  sl_transfer_in, in_accept_in : Wafer # SluiceId;    % Sluice->Inside (transfer_out)
  in_transfer_out, sl_accept_out : Wafer # SluiceId;  % Inside->Sluice (transfer_in)

  % Alarm broadcast
  alarm_signal, alarm_check : Bool;

% Synchronized communication actions
  c_place_ext, c_pick_ext : Wafer # SluiceId;
  c_transfer_inside_out, c_transfer_inside_in : Wafer # SluiceId;
  c_alarm : Bool;

% ----------------------------------------------
% Helpers
% ----------------------------------------------
map
  validSluice  : SluiceId -> Bool;
  validWafer   : Wafer    -> Bool;
  validInCell  : Nat      -> Bool;
  validOutCell : Nat      -> Bool;
  sid2n        : SluiceId -> Nat;
  w2n          : Wafer    -> Nat;

var k:Nat; sid:SluiceId; wf:Wafer;

eqn
  sid2n(s(k)) = k;
  w2n(w(k))   = k;

  validSluice(sid) = sid2n(sid) < NUM_SLUICES;
  validWafer(wf)   = w2n(wf)    < NUM_WAFERS;
  validInCell(k)   = k < NUM_FOUP_IN;
  validOutCell(k)  = k < NUM_FOUP_OUT;

% ==============================================================
% COMPONENT 1: Outside Robot Controller (Region 1)
% ==============================================================
proc OutsideRobotController(
  phase    : Wafer -> Nat,      % 0: not yet entered; 1: in system
  out_occ  : Nat   -> Bool,     % Output rack occupancy
  alarm    : Bool
) =
  % Input: Pick from input FOUP and place at sluice outer port
  sum i:Nat, sid:SluiceId . (
      i < NUM_WAFERS && validInCell(i) && validSluice(sid) && 
      !alarm && phase(w(i)) == 0
    ) -> pick(w(i), in_cell(i)) . wafer_entered_system(w(i)) . 
         or_place_ext(w(i), sid) .
         OutsideRobotController(phase[w(i)->1], out_occ, alarm)
+
  % Output: Pick from sluice outer port and place to output rack
  sum sid:SluiceId, i:Nat, oc:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      validOutCell(oc) && !out_occ(oc) && !alarm
    ) -> or_pick_ext(w(i), sid) . 
         place(w(i), out_cell(oc)) . wafer_output(w(i)) .
         OutsideRobotController(phase, out_occ[oc->true], alarm)
+
  % Receive alarm status
  sum a:Bool . alarm_check(a) . 
    OutsideRobotController(phase, out_occ, a)
;

% ==============================================================
% COMPONENT 2: Sluice Controller (Region 2, instantiated per sluice)
% ==============================================================
proc SluiceController(
  sid       : SluiceId,
  in_open   : Bool,
  out_open  : Bool,
  mode      : PMode,
  buf_occ   : Bool,
  buf_w     : MOptWafer,
  ext_port_w: MOptWafer,
  alarm     : Bool
) =
  % =====================
  % Door Operations
  % =====================
  (mode == Atm && !out_open && !in_open && !alarm) 
    -> open_outer(sid) .
       SluiceController(sid, in_open, true, mode, buf_occ, buf_w, ext_port_w, alarm)
+
  (out_open) 
    -> close_outer(sid) .
       SluiceController(sid, in_open, false, mode, buf_occ, buf_w, ext_port_w, alarm)
+
  (mode == Vac && !in_open && !out_open && !alarm) 
    -> open_inner(sid) .
       SluiceController(sid, true, out_open, mode, buf_occ, buf_w, ext_port_w, alarm)
+
  (in_open) 
    -> close_inner(sid) .
       SluiceController(sid, false, out_open, mode, buf_occ, buf_w, ext_port_w, alarm)
+
  % =====================
  % Pressure Management
  % =====================
  (!in_open && !out_open && mode == Atm && buf_occ && !alarm) 
    -> start_pump_down(sid) .
       SluiceController(sid, in_open, out_open, Pumping, buf_occ, buf_w, ext_port_w, alarm)
+
  (mode == Pumping) 
    -> vacuum_achieved(sid) .
       SluiceController(sid, in_open, out_open, Vac, buf_occ, buf_w, ext_port_w, alarm)
+
  (!in_open && !out_open && mode == Vac) 
    -> start_vent(sid) .
       SluiceController(sid, in_open, out_open, Venting, buf_occ, buf_w, ext_port_w, alarm)
+
  (mode == Venting) 
    -> atmosphere_achieved(sid) .
       SluiceController(sid, in_open, out_open, Atm, buf_occ, buf_w, ext_port_w, alarm)
+
  % Vacuum fault
  (mode == Pumping && !alarm)
    -> vacuum_fault(sid) . 
       SluiceController(sid, in_open, out_open, Atm, buf_occ, buf_w, ext_port_w, alarm)
+
  % =====================
  % Transfers with Outside Robot
  % =====================
  % Accept wafer from outside robot to outer port
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && ext_port_w == none
    ) -> sl_accept_ext(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, some(w(i)), alarm)
+
  % Transfer from outer port to buffer (input path)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && !buf_occ &&
      ext_port_w == some(w(i))
    ) -> transfer_in(w(i), sid) . place(w(i), sl_in(sid)) .
         SluiceController(sid, in_open, out_open, mode, true, some(w(i)), none, alarm)
+
  % Release wafer from outer port to outside robot
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm &&
      ext_port_w == some(w(i))
    ) -> sl_release_ext(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, none, alarm)
+
  % Transfer from buffer to outer port (output path)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      out_open && !in_open && mode == Atm && buf_occ &&
      buf_w == some(w(i)) && ext_port_w == none
    ) -> transfer_out(w(i), sid) . place(w(i), sl_out(sid)) .
         SluiceController(sid, in_open, out_open, mode, false, none, some(w(i)), alarm)
+
  % =====================
  % Transfers with Inside Controller
  % =====================
  % Transfer from buffer to inside (vacuum side)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      in_open && !out_open && mode == Vac && buf_occ && !alarm &&
      buf_w == some(w(i))
    ) -> sl_transfer_in(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, false, none, ext_port_w, alarm)
+
  % Accept wafer from inside to buffer (vacuum side)
  sum i:Nat . (
      i < NUM_WAFERS && validWafer(w(i)) &&
      in_open && !out_open && mode == Vac && !buf_occ && !alarm
    ) -> sl_accept_out(w(i), sid) .
         SluiceController(sid, in_open, out_open, mode, true, some(w(i)), ext_port_w, alarm)
+
  % Receive alarm status
  sum a:Bool . alarm_check(a) . 
    SluiceController(sid, in_open, out_open, mode, buf_occ, buf_w, ext_port_w, a)
;

% ==============================================================
% COMPONENT 3: Inside Controller (Region 3 + Alarm)
% ==============================================================
proc InsideController(
  is_waiting: Wafer -> Bool,
  stage_busy: Bool,
  on_stage  : MOptWafer,
  processed : Wafer -> Bool,
  alarm     : Bool
) =
  % =====================
  % ALARM Control
  % =====================
  (!alarm) 
    -> trigger_alarm . alarm_signal(true) .
       InsideController(is_waiting, stage_busy, on_stage, processed, true)
+
  (alarm) 
    -> restart_system . alarm_signal(false) .
       InsideController(is_waiting, stage_busy, on_stage, processed, false)
+
  % =====================
  % Transfers with Sluice (Inside side)
  % =====================
  % Accept wafer from sluice buffer to waiting area
  sum sid:SluiceId, i:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      !alarm && !is_waiting(w(i))
    ) -> in_accept_in(w(i), sid) . transfer_out(w(i), sid) . place(w(i), waiting) .
         InsideController(is_waiting[w(i)->true], stage_busy, on_stage, processed, alarm)
+
  % Send wafer from waiting area to sluice buffer (for output)
  sum sid:SluiceId, i:Nat . (
      validSluice(sid) && i < NUM_WAFERS && validWafer(w(i)) &&
      !alarm && is_waiting(w(i)) && processed(w(i))
    ) -> in_transfer_out(w(i), sid) . transfer_in(w(i), sid) . place(w(i), sl_in(sid)) .
         InsideController(is_waiting[w(i)->false], stage_busy, on_stage, processed, alarm)
+
  % =====================
  % Stage Operations
  % =====================
  % Load stage and run projection
  sum i:Nat . (
      i < NUM_WAFERS && is_waiting(w(i)) && !stage_busy && !alarm && !processed(w(i))
    ) -> load_stage(w(i)) . start_projection(w(i)) . end_projection(w(i)) .
         InsideController(is_waiting[w(i)->false], true, some(w(i)), 
                         processed[w(i)->true], alarm)
+
  % Unload stage back to waiting
  sum i:Nat . (
      i < NUM_WAFERS && on_stage == some(w(i)) && !alarm
    ) -> unload_stage(w(i)) . place(w(i), waiting) .
         InsideController(is_waiting[w(i)->true], false, none, processed, alarm)
+
  % Broadcast alarm status
  alarm_signal(alarm) .
    InsideController(is_waiting, stage_busy, on_stage, processed, alarm)
;

% ==============================================================
% INITIALIZATION with Parallel Composition
% ==============================================================
init
  allow({
    % Observable actions
    open_inner, close_inner, open_outer, close_outer,
    start_pump_down, vacuum_achieved, start_vent, atmosphere_achieved,
    vacuum_fault,
    transfer_in, transfer_out,
    pick, place,
    load_stage, start_projection, end_projection, unload_stage,
    wafer_entered_system, wafer_output,
    trigger_alarm, restart_system,
    % Synchronized communication actions
    c_place_ext, c_pick_ext,
    c_transfer_inside_out, c_transfer_inside_in,
    c_alarm
  },
  comm({
    % Outside Robot <-> Sluice synchronization
    or_place_ext | sl_accept_ext -> c_place_ext,
    or_pick_ext | sl_release_ext -> c_pick_ext,
    % Sluice <-> Inside synchronization
    sl_transfer_in | in_accept_in -> c_transfer_inside_out,
    in_transfer_out | sl_accept_out -> c_transfer_inside_in,
    % Alarm broadcast
    alarm_signal | alarm_check -> c_alarm
  },
    OutsideRobotController(
      lambda wf:Wafer . 0,      % phase
      lambda k:Nat    . false,  % out_occ
      false                     % alarm
    )
    ||
    SluiceController(
      s(0),                     % sluice id 0
      false,                    % in_open
      false,                    % out_open
      Vac,                      % mode
      false,                    % buf_occ
      none,                     % buf_w
      none,                     % ext_port_w
      false                     % alarm
    )
    ||
    SluiceController(
      s(1),                     % sluice id 1
      false,                    % in_open
      false,                    % out_open
      Vac,                      % mode
      false,                    % buf_occ
      none,                     % buf_w
      none,                     % ext_port_w
      false                     % alarm
    )
    ||
    InsideController(
      lambda wf:Wafer . false,  % is_waiting
      false,                    % stage_busy
      none,                     % on_stage
      lambda wf:Wafer . false,  % processed
      false                     % alarm
    )
  ));